# Node.js가 프로그래머에게 주는 의미

웹 2.0 시대는 웹 사이트를 웹 응용프로그램으로 진화시켰고 진화는 클라이언트 측에서 또 서버 측에서 여전히 진행 중이다. 이러한 변화의 흐름 속에 웹 브라우저에서 가장 큰 역할을 담당하고 있는 기술 중 하나가 프로그래밍 언어인 자바스크립트라는 것에 이의를 제기할 프로그래머는 많지 않을 것이다. 엄청난 속도의 인터넷 보급, 그리고 스마트폰과 태블릿의 확산은 자바스크립트가 수를 헤아릴 수 없이 많은 기기에서 실행되도록 만들었다. 집에서, 사무실에서, 출퇴근길 대중교통 안에서, 식당이나 카페에서 수많은 사람들이 PC로, 노트북으로, 그리고 스마트폰과 태블릿으로 인터넷에 접속하여 원하는 정보를 검색하고 음악과 영화를 감상하고 게임을 즐긴다. 이러한 활동의 중심에 자바스크립트가 끊임 없이 동작하고 있다.

IT 혁명의 중심에 있는 웹 플랫폼 위에서 구동되는 프로그램을 개발하는 수많은 프로그래머들은 자바스크립트에 매우 익숙하다. 이들이 웹 클라이언트가 아닌 경험해보지 못했던 생소한 환경에서 구동되는 프로그램을 작성할 때 이미 익숙한 프로그래밍 언어를 사용할 수 있다면 얼마나 반가울까? 자바스크립트는 지금 웹 브라우저를 벗어나 그 영향력이 빠르게 확대되고 있기 때문에 자바스크립트에 친숙한 웹 클라이언트 프로그래머들에게 지금은 새로운 플랫폼에 도전하기에 아주 좋은 기회이다.

자바스크립트로 한 벌의 코드를 작성하면 여러 모바일 플랫폼용 코드를 빌드 할 수 있는 개발 도구가 시중에 판매되고 있고, 윈도 8과 마이크로소프트 오피스에서 구동되는 프로그램을 자바스크립트로 작성할 수 있는 시대이다. 하지만 그 어떤 플랫폼보다 자바스크립트가 네트워크 서버 프로그래밍 환경에 진출했다는 것이야 말로 가장 혁명적이고 가장 주목해야 할 부분이 아닐까 생각된다. 바로 Node.js가 그것을 가능케 한다.

Node.js는 확장 가능한 고성능 네트워크 서버 코드를 빠르고 간결하게 작성할 수 있게 해주는 플랫폼이다. 바로 자바스크립트라는 프로그래밍 언어를 사용해서 말이다. 자바스크립트를 사용한 클라이언트 개발이 주력인 프로그래머들 중 다수는 서버 프로그래밍 세계로의 영역 확대에 큰 장벽이 있었을 수도 있다. 기존 서버 프로그래밍 환경의 좀 더 안정적이지만 경직된 문법의 언어, 다중 스레드 프로그래밍, 고효율 코드 작성 등 이전에 경험해보지 못했던 몇몇 기술과 문화가 막연한 두려움으로 느껴지는 개발자들도 있었을 것이다. 하지만 Node.js로 인해 웹 클라이언트에 익숙한 개발자들이 기존이 익히고 있던 기술과 코딩 문화를 그대로 서버 영역으로 확대할 수 있는 기회가 생겼다.

그러면 Node.js의 어떤 특징이 웹 브라우저가 주 활동 무대였던 자바스크립트를 네트워크 서버 환경에 적합한 언어의 반열에 오르게 한 것일까? 각자 여러 가지 이유들이 떠오르겠지만 필자는 기존의 것들에 비해 혁명적인 성능을 보여준 Chrome 웹 브라우저의 자바스크립트 엔진인 V8과 비동기 프로그래밍 모델이 아닐까 생각한다. 이것들을 비롯해 Node.js의 특징들에 대해서 좀 더 얘기할 필요가 있다.

# Node.js의 주요 특징

## JavaScript의 유연성

Node.js는 자바스크립트 언어 기반의 개발 플랫폼이다. 자바스크립트가 웹 클라이언트 개발 언어로 오랫동안 흔들림 없이 입지를 굳힐 수 있었던 것은 외부 요인도 있겠지만 자바스크립트만의 매력이 분명 크게 작용했을 것이다. 프로그래밍 언어를 나누는 기준에는 여러 가지가 있다. 그 중 하나가 정적 언어와 동적 언어로 나누는 기준이다. 정적 언어로 대표적인 것은 C, C++, Java, C# 등이 있다. 이들 언어는 개체가 생성되는 시점에 개체의 형식이 결정되고 이 형식이 정의하고 있는 속성과 행위를 가지게 되면 개체가 수명을 다 할 때까지 속성과 행위가 추가되거나 삭제되지 않는다. 반면 자바스크립트는 동적 언어이다. 자바스크립트 개체는 만들어질 때 미리 정해진 형식에 의해 속성과 행위가 정의되지 않으며 개체의 수명주기 중 속성과 행위는 얼마든지 추가되고 제거될 수 있다. 프로그래머는 자바스크립트의 이러한 특성을 이용해 좀 더 민첩하게 주어진 상황에 대처할 수 있다.

또 자바스크립트는 즉각적인 콜백(callback) 함수를 정의할 수 있도록 클로저(closure)를 구현한다. 함수 블록 안에서 또 다른 내부 함수를 만드는 이 기능은 내부 함수가 부모 함수의 접근 범위에 있는 데이터에 접근할 수 있도록 허용함으로써 프로그래머가 유연하고 간결한 코드를 작성할 수 있게 한다.

이러한 유연성은 자바스크립트를 웹 클라이언트에서 구동되기에 적합한 언어로 만들었고 이제는 Node.js를 통해 서버 프로그램 개발에도 이러한 유연성을 활용할 수 있게 되었다. 현대의 소프트웨어는 고정적이지 않다. 오히려 살아 숨쉬며 끊임 없이 변화하는 존재에 가깝다. 이런 환경에 대처하기에 자바스크립트가 가진 유연함은 Node.js와 서버 프로그래머에게 큰 힘이 된다.

## 고성능 JavaScript엔진 V8

V8은 Google이 웹 브라우저 Chrome을 위해 개발한 오픈 소스 자바스크립트 엔진이다. 고성능, 고효율 자바스크립트 실행 환경은 새로운 웹 브라우저로서의 Chrome이 가진 가장 중요한 과제 중 하나였다. 그 이유는 웹 표준 기술에 기반한 웹 응용프로그램의 사용자 경험을 극대화하기에 기존 브라우저의 자바스크립트 엔진의 성능은 충분하지 않았기 때문이다. Chrome은 높은 성능의 자바스크립트엔진 V8을 탑재해 Chrome 브라우저를 사용하는 것 만으로도 이미 전 세계에 배포되어있는 수많은 자바스크립트 기반 웹 응용프로그램의 사용자 경험을 높일 수 있었다. Chrome은 처음 세상에 공개되던 당시 가장 점유율이 높았던 브라우저인 Internet Explorer와 비교해 정말 믿기 어려운 자바스크립트 실행 속도를 보여줬다.

V8은 자바스크립트 코드를 인터프리터로 통역(interpret)하거나 중간 언어로 번역(compile)하는 기존의 방법 대신 각 코드를 실행하기 전 각 플랫폼에 최적화된 기계어로 번역하고 이를 캐시에 보관해 재사용한다. 그리고 외부로 드러나지는 않지만 가능한 경우 자바스크립트가 가진 동적 언어로서의 특징과 상반되는 형식 기반 멤버 바인딩을 내부적으로 사용한다. 이외에도 다양한 방법들을 사용해 V8은 자바스크립트 프로그램의 성능을 컴파일 언어로 작성된 프로그램의 성능과 아주 가까운 위치까지 끌어올린다. 물론 이러한 V8의 동작 원리를 잘 이해하면 좀 더 효율적이고 높은 성능을 내는 프로그램을 작성할 수 있지만 필수적으로 알아야 할 내용은 아니다. 기존에 사용하던 방법대로 자바스크립트 코드를 작성해도 대부분의 경우 V8은 충분한 성능을 제공한다.

## 비동기 이벤트 방식

비동기 이벤트 프로그래밍 모델은 클라이언트에서든 서버에서든 자바스크립트 프로그래머가 반드시 이해해야 할 개념 중 하나이다. 웹 클라이언트 자바스크립트 프로그래머라면 혹여 용어가 생소하더라고 걱정할 필요가 전혀 없다. XMLHttpRequest 개체를 통해 이미 이러한 기법을 익숙하게 사용하고 있었을 테니까.

XMLHttpRequest를 사용한 비동기 처리 과정에 대해 잠깐 살펴보자. 웹 브라우저에서 구동되는 자바스크립트는 단일 스레드 모델을 채택한다. 웹 브라우저가 컨트롤을 통해 사용자의 입력을 받아들이고 브라우저 화면을 그리는 등의 작업이 이루어지는 스레드를 자바스크립트가 공유하는 방식이다. 바꿔 말하면 자바스크립트가 사용하는 스레드는 자바스크립트에게 뿐만 아니라 웹 브라우저에게도 매우 소중한 자원인 것이다. 자바스크립트의 각 작업은 이 하나의 스레드 안에서 프레임이란 단위로 나뉘어 처리된다. 그래서 자바스크립트가 하나의 프레임 안에서 오랫동안 작업을 처리하면 해당 작업이 모두 완료될 때까지 웹 브라우저는 사용자의 입력을 받아들이거나 화면을 갱신할 수 없는 상태로 멈춰있게 된다. 그렇기 때문에 XMLHttpRequest를 사용해 웹 서버와 통신할 때 요청을 보낸 후 서버의 응답을 수신할 때까지 프레임에서 기다리기는 동기적 방식보다는 최대한 신속히 스레드 점유를 다음 프레임 또는 웹 브라우저에 양보하고 서버로부터 응답이 오면 그 때 새로운 프레임을 할당 받아 이후 작업을 처리하는 비동기적 방식을 사용한다.

Node.js 역시 하나의 프로그램 인스턴스는 하나의 스레드만 사용한다. Node.js 프로그램은 일반적으로 모든 외부 컴포넌트와 의사 소통할 때 비동기 방식을 사용해 대기 시간 동안의 자원 낭비를 최소화한다. 그러면 왜 기존의 플랫폼에서 개발하는 프로그래머들은 자원을 경제적으로 활용할 수 있는 비동기 프로그래밍 모델을 사용하지 않는 걸까? Node.js 창시자인 Ryan Lienhart Dahl은 두 가지 이유를 제시한다.

하나는 개발 인프라 부족이다. 기존 개발 플랫폼에서 사용되는 많은 라이브러리들이 비동기 프로그래밍을 지원하지 않는다는 얘기다. 하지만 이 의견은 어떤 환경에서는 적합하지만 또 어떤 환경에서는 딱 들어맞는 얘기는 아니다. 예를 들어 ASP.NET은 언제나 비동기 프로그래밍 도구를 지원해 왔고 점차 확대 되었지만 아직도 많은 프로그래머들은 동기적 방식의 프로그래밍만을 사용한다. 왜 일까? Ryan Dahl은 많은 플랫폼에서 비동기 프로그래밍이 주류가 되지 않는 또 다른 이유로 문화적 차이를 얘기한다.

이미 비동기 프로그래밍 지원이 존재한다 하더라도 동기적 방식이 훨씬 오랫동안 자리잡고 있었고 최근까지 비동기 프로그래밍은 프로그래머에게 동기적 방식에 비해 더 깊은 사고와 더 많은 양의 코드를 요구했다는 것은 부정하기 힘들다. 동기적 방식과 비동기적 방식 모두를 제공하는 인프라에서 프로그래머들이 비교적 손쉬운 동기적 프로그래밍을 선호하는 경우가 많았다. 반면 대부분의 Node.js 입출력 모듈은 비동기 방식만을 지원하고 이미 언급했듯이 기존의 자바스크립트 프로그래머들은 이러한 방식에 매우 익숙하다. Node.js는 태생적으로 고효율 비동기 프로그래밍에 필요한 문화적 환경을 갖추고 있다고 봐도 무리가 없을 것이다.

## 단일 스레드 모델

이미 언급되었듯 Node.js는 단일 스레드 환경을 제공한다. 다양한 요인들이 결합된 데이터에 대한 통계적 분석 연산의 경우 다중 스레드 모델이 더 적합하다. 필요한 구간에 여러 개의 스레드를 배치해 시스템 자원을 최대한 활용하여 빠르게 연산을 완료하도록 설계할 수 있다. 하지만 이와 같은 상황을 모든 프로그램이 맞닥뜨리는 것은 아니다. 요청에 대한 빠른 반응을 요구하는 네트워크 서버의 프로그램의 경우 단일 스레드 모델이 더 적합할 수도 있다. 하나의 스레드만 이용하는 방식은 다음과 같은 장점이 있다.

자원 접근에 대한 동기화를 신경 쓰지 않아도 된다. 여러 개의 스레드가 공유된 자원을 사용할 경우 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근이 통제되어야 하며 이 작업은 프로그래머에게 많은 노력을 요구하고 비용 또한 발생한다. 단일 스레드 모델에서는 이러한 작업이 필요 없다.

문맥 교환(context switch) 작업을 요구하지 않습니다. 문맥 교환은 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용을 필요로 한다.

## npm

npm은 Node.js를 위한 패키지 관리자이다. 수만 개의 라이브러리 패키지가 Node.js 프로그래머에게 도움을 주기 위해 등록되어 있다. 누구나 npm을 통해 필요한 프로그램을 설치해 사용할 수 있고 또 누구나 자신이 만든 프로그램을 npm에 배포할 수 있다. npm에 배포되는 패키지는 package.json 파일을 사용해 프로그램의 여러 가지 특징을 설명하고 버전 관리를 한다. 지금도 새로운 패키지들이 계속 등록되고 있으며 개발자는 https://npmjs.org에서 필요한 라이브러리를 검색해 사용할 수 있다.

# Node.js의 단점과 극복 방법

물론 다른 모든 개발 플랫폼이 그러하듯 Node.js가 장점만을 가진 완벽한 플랫폼은 아니다. Node.js의 장점은 물론 단점도 이해하고 이를 극복하는 방법을 익힌다면 Node.js 프로그래밍에 큰 도움이 된다. 그래서 Node.js의 몇 가지 단점에 대해 간단히 알아보고 넘어가자. 여기에서 언급된 내용들은 실제 서비스를 설계하고 구현하는 과정에서 더욱 자세히 살펴보게 될 것이다.

## 컴파일러 지원 부재

앞서 동적 언어로서 자바스크립트의 유연성에 대해 언급했지만 컴파일러가 지원하는 코드 오류 검사는 C++와 같은 컴파일 언어의 강력한 장점입니다. 물론 정적 형식이 프로그램의 모든 오류를 검출해내지는 못하지만 프로그래머가 저지르는 실수의 많은 부분을 프로그램이 실행되기 전에 검출해 주는 것은 엄연한 사실이다. 반면 자바스크립트 프로그램은 실행 단계에 들어가기 전에 자바스크립트 엔진으로부터 이러한 검사를 받지 않는다. 이는 즉 오류의 위험이 높아지는 것을 의미한다.

JSLint 또는 JSHint는 자바스크립트 코드의 문법적 오류와 실행 중 문제를 일으킬 가능성이 있는 코드를 검출해 주는 도구다. 뿐만 아니라 다양한 선택 사항을 제공하여 소스 코드를 배포하기 전에 개발팀의 코딩 규약 준수여부 등을 검사할 수도 있다.

단위 테스트 또한 자바스크립트 프로그램이 운영 환경에 배포되기 전에 내재된 오류를 검출해 주는 좋은 도구다. 전체 프로그램 중 얼마나 많은 코드가 단위 테스트에 의해 실행되는 지를 나타내는 척도인 코드 커버리지를(code coverage) 높여 최대한 많은 오류를 미리 찾아내는 것이 중요하다.

## 단일 스레드 모델

우리는 단일 스레드 프로그래밍 모델의 장점에 대해 얘기했지만 물론 단점 또한 존재한다. 요즘의 일반적인 시스템은 여러 개의 CPU를 가지고 있습니다. 하나의 스레드를 사용하는 프로그램은 여러 개의 CPU를 활용하지 못한다. Node.js 프로그램이 시스템이 가진 프로세서를 최대한 활용하게 하려면 cluster 모듈을 사용하거나 외부에서 여러 개의 프로그램 인스턴스를 실행시키는 방법을 사용한다.

이 때 고려해야 할 문제가 있는데 바로 다수의 프로그램 인스턴스가 어떻게 상태를 공유할 것인가에 대한 문제다. 사실 이것은 다중 스레드 환경의 서버 프로그램도 확장성을 확보하기 위해 풀어야 할 숙제이긴 하다. 단순하고 빠른 메모리 기반 NoSQL 데이터베이스인 Redis는 좋은 고려대상이다. 하지만 서버 프로그램 인스턴스 간 상태 공유를 최소화 하거나 가능하면 없애는 방향으로 아키텍처를 설계하는 것이 가장 바람직하다.

## 콜백 지옥

비동기 이벤트 방식 프로그램이 여러 가지 장점을 가지고 있지만 데이터베이스, 메시지 큐, 웹 API, 파일 시스템 등에 대한 입출력이 복합적으로 연관된 Node.js 프로그램을 작성하다 보면 이벤트 메시지를 수신하기 위한 다수의 콜백 함수가 직렬적으로 연결되어 이해하기도 관리하기도 쉽지 않은 코드가 만들어지는 경우를 자주 보게 된다. 이것을 가리켜 ‘콜백 지옥’이라고 부른다.

많은 자바스크립트 프로그래머들이 콜백 지옥을 벗어나기 위해 promise 디자인 패턴 구현체를 사용한다. 조금 더 자바스크립트 친화적 설명을 하자면 Common JS Promises/A 사양을 준수하는 라이브러리를 이용해 콜백 지옥을 탈출한다. 대표적인 라이브러리는 Q, RSVP, when 등이 있다.

여기에 더해 아직 진행 중이지만 ES6에 generator가 포함되어 배포되면 자바스크립트 프로그래머들은 동기적 프로그램을 작성하는 과정과 매우 유사하게 비동기 코드를 만들 수 있게 된다. 이 글이 작성되는 시점에는 generator를 적용하려면 Node.js 버전 0.11.9 이상에서 --harmony 플래그를 사용해야한다.

# 결론

Node.js의 장단점을 포함한 여러 가지 특징들을 살펴봤다. 이 내용들이 Node.js를 이용해 네트워크 서버 프로그래밍을 시작할 때 크고 작은 도움이 될 것이다. 여기에 Node.js의 특징을 하나 더하자면 재미있다는 것입니다. 프로그래머에게 재미있다는 것은 아주 큰 자극과 동기가 된다. 이제 우리는 고성능의 확장 가능하고 유연한 서버 프로그램을 재미있게 개발할 준비가 되었다.
